#Requires -Version 5.1
<#
.SYNOPSIS
    üöÄ CHATBOT GOMARCO - Enterprise Auto-Updater PowerShell Edition
    
.DESCRIPTION
    Script empresarial avanzado para automatizar la actualizaci√≥n y ejecuci√≥n
    del Chatbot GOMARCO con caracter√≠sticas enterprise-grade.
    
.PARAMETER ConfigurationType
    Tipo de configuraci√≥n de build (Debug/Release)
    
.PARAMETER SkipGitPull
    Omite la actualizaci√≥n desde Git
    
.PARAMETER Verbose
    Muestra informaci√≥n detallada del proceso
    
.EXAMPLE
    .\ActualizarYEjecutar.ps1
    
.EXAMPLE
    .\ActualizarYEjecutar.ps1 -ConfigurationType Release -Verbose
    
.NOTES
    Versi√≥n: 2.1 Enterprise (Fixed Syntax)
    Desarrollado por: DevOps Team GOMARCO
    Requisitos: .NET 8 SDK, PowerShell 5.1+
    CAMBIOS: Corregidos errores de sintaxis y agregado soporte para cambios de API
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)]
    [ValidateSet("Debug", "Release")]
    [string]$ConfigurationType = "Debug",
    
    [Parameter(Mandatory=$false)]
    [switch]$SkipGitPull,
    
    [Parameter(Mandatory=$false)]
    [switch]$ForceRecompile
)

# ====================================================================
# CONFIGURACI√ìN EMPRESARIAL
# ====================================================================
$ErrorActionPreference = "Stop"
$ProgressPreference = "SilentlyContinue"

$Config = @{
    ProjectName = "ChatbotGomarco"
    SolutionFile = "chatbot.sln"
    ProjectFile = "ChatbotGomarco.csproj"
    BuildConfig = $ConfigurationType
    LogDirectory = "logs"
    MaxLogFiles = 10
}

# ====================================================================
# FUNCIONES UTILITARIAS ENTERPRISE
# ====================================================================

function Write-LogMessage {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [ValidateSet("INFO", "WARN", "ERROR", "SUCCESS")]
        [string]$Level = "INFO"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    
    # Color coding for console
    switch ($Level) {
        "INFO"    { Write-Host $logEntry -ForegroundColor Cyan }
        "WARN"    { Write-Host $logEntry -ForegroundColor Yellow }
        "ERROR"   { Write-Host $logEntry -ForegroundColor Red }
        "SUCCESS" { Write-Host $logEntry -ForegroundColor Green }
    }
    
    # Write to log file
    if ($script:LogFile) {
        $logEntry | Add-Content -Path $script:LogFile -Encoding UTF8
    }
}

function Test-Prerequisites {
    Write-LogMessage "üîç Verificando prerrequisitos del sistema..." -Level INFO
    
    # Verificar .NET SDK
    try {
        $dotnetVersion = & dotnet --version 2>$null
        if ($LASTEXITCODE -eq 0) {
            Write-LogMessage "‚úÖ .NET SDK detectado: $dotnetVersion" -Level SUCCESS
        } else {
            throw "No se detect√≥ .NET SDK"
        }
    }
    catch {
        Write-LogMessage "‚ùå .NET 8 SDK no est√° instalado" -Level ERROR
        throw
    }
    
    # Verificar archivos del proyecto
    @($Config.SolutionFile, $Config.ProjectFile) | ForEach-Object {
        if (-not (Test-Path $_)) {
            Write-LogMessage "‚ùå Archivo requerido no encontrado: $_" -Level ERROR
            throw "Archivo del proyecto faltante: $_"
        }
    }
    
    # Verificar e instalar Ollama si es necesario
    Test-AndInstall-Ollama
    
    Write-LogMessage "‚úÖ Todos los prerrequisitos verificados" -Level SUCCESS
}

function Test-AndInstall-Ollama {
    Write-LogMessage "üîç Verificando instalaci√≥n de Ollama..." -Level INFO
    
    try {
        # Verificar si Ollama est√° instalado
        $ollamaInstalled = $false
        try {
            $null = & ollama --version 2>$null
            if ($LASTEXITCODE -eq 0) {
                $ollamaInstalled = $true
                Write-LogMessage "‚úÖ Ollama ya est√° instalado" -Level SUCCESS
            }
        }
        catch {
            # Ollama no est√° en PATH
        }
        
        if (-not $ollamaInstalled) {
            Write-LogMessage "üì¶ Ollama no detectado - iniciando instalaci√≥n autom√°tica..." -Level INFO
            Install-Ollama
        }
        
        # Verificar y descargar modelos AI enterprise
        Ensure-AI-Models
    }
    catch {
        Write-LogMessage "‚ö†Ô∏è  Error configurando Ollama - continuando sin IA local" -Level WARN
        Write-LogMessage "    El sistema funcionar√° solo con OpenAI si est√° configurado" -Level WARN
    }
}

function Install-Ollama {
    Write-LogMessage "üöÄ Instalando Ollama para IA local..." -Level INFO
    
    try {
        # Usar el enlace directo del instalador de Ollama (GitHub releases)
        $ollamaUrl = "https://github.com/ollama/ollama/releases/latest/download/OllamaSetup.exe"
        $tempPath = [System.IO.Path]::GetTempPath()
        $installerPath = Join-Path $tempPath "OllamaSetup.exe"
        
        Write-LogMessage "    ‚îî‚îÄ Descargando instalador desde GitHub releases..." -Level INFO
        
        # Limpiar instalador anterior si existe
        if (Test-Path $installerPath) {
            Remove-Item $installerPath -Force -ErrorAction SilentlyContinue
        }
        
        # Descargar instalador con mejor manejo de errores
        try {
            # Usar Invoke-WebRequest con UserAgent para evitar bloqueos
            $webRequest = @{
                Uri = $ollamaUrl
                OutFile = $installerPath
                UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
                TimeoutSec = 120
                ErrorAction = "Stop"
            }
            Invoke-WebRequest @webRequest
            
            Write-LogMessage "    ‚îî‚îÄ Descarga completada: $(Get-Item $installerPath | Select-Object -ExpandProperty Length) bytes" -Level INFO
        }
        catch {
            Write-LogMessage "‚ùå Error descargando: $($_.Exception.Message)" -Level ERROR
            throw "No se pudo descargar el instalador de Ollama"
        }
        
        # Verificar que el archivo descargado es v√°lido
        if ((Test-Path $installerPath) -and (Get-Item $installerPath).Length -gt 1MB) {
            Write-LogMessage "    ‚îî‚îÄ Archivo v√°lido detectado, ejecutando instalador..." -Level INFO
            
            # Ejecutar instalador en modo silencioso
            try {
                $installProcess = Start-Process -FilePath $installerPath -ArgumentList "/S" -Wait -PassThru -NoNewWindow
                
                if ($installProcess.ExitCode -eq 0) {
                    Write-LogMessage "‚úÖ Ollama instalado exitosamente" -Level SUCCESS
                    
                    # Esperar para que el servicio se inicialice
                    Write-LogMessage "    ‚îî‚îÄ Esperando inicializaci√≥n del servicio..." -Level INFO
                    Start-Sleep -Seconds 10
                    
                    # Verificar instalaci√≥n
                    $ollamaInstalled = $false
                    for ($i = 0; $i -lt 3; $i++) {
                        try {
                            $null = & ollama --version 2>$null
                            if ($LASTEXITCODE -eq 0) {
                                $ollamaInstalled = $true
                                break
                            }
                        }
                        catch {
                            Start-Sleep -Seconds 3
                        }
                    }
                    
                    if ($ollamaInstalled) {
                        Write-LogMessage "‚úÖ Ollama verificado y funcionando" -Level SUCCESS
                    } else {
                        Write-LogMessage "‚ö†Ô∏è  Ollama instalado - requiere reiniciar terminal/PowerShell" -Level WARN
                        Write-LogMessage "    ‚îî‚îÄ Ejecuta: refreshenv o reinicia PowerShell" -Level INFO
                    }
                } else {
                    throw "Instalador termin√≥ con c√≥digo de error: $($installProcess.ExitCode)"
                }
            }
            catch {
                throw "Error ejecutando instalador: $($_.Exception.Message)"
            }
            
            # Limpiar archivo temporal
            Remove-Item $installerPath -Force -ErrorAction SilentlyContinue
        } else {
            throw "Archivo descargado inv√°lido o demasiado peque√±o"
        }
    }
    catch {
        Write-LogMessage "‚ùå Error instalando Ollama: $($_.Exception.Message)" -Level ERROR
        Write-LogMessage "" -Level INFO
        Write-LogMessage "üìã INSTALACI√ìN MANUAL RECOMENDADA:" -Level INFO
        Write-LogMessage "    1. Visita: https://ollama.com/download" -Level INFO
        Write-LogMessage "    2. Descarga 'Download for Windows'" -Level INFO
        Write-LogMessage "    3. Ejecuta el instalador como administrador" -Level INFO
        Write-LogMessage "    4. Reinicia PowerShell y ejecuta: ollama pull phi3:mini" -Level INFO
        Write-LogMessage "" -Level INFO
        throw
    }
}

function Ensure-AI-Models {
    Write-LogMessage "üß† Verificando e instalando modelos AI empresariales..." -Level INFO
    
    # üéØ CONFIGURACI√ìN DE MODELOS ENTERPRISE
    $ModelosRecomendados = @(
        @{
            Nombre = "deepseek-r1:7b"
            Descripcion = "DeepSeek-R1 7B (Razonamiento Avanzado)"
            Prioridad = 1
            Categoria = "reasoning"
        },
        @{
            Nombre = "llama3.1-claude:latest"
            Descripcion = "Llama 3.1 + Claude 3.5 Sonnet"
            Prioridad = 2
            Categoria = "conversational"
        },
        @{
            Nombre = "phi3:mini"
            Descripcion = "Phi-3-Mini (Microsoft - Estable)"
            Prioridad = 3
            Categoria = "stable"
        },
        @{
            Nombre = "deepseek-v3:latest"
            Descripcion = "DeepSeek-V3 (General)"
            Prioridad = 4
            Categoria = "general"
        },
        @{
            Nombre = "deepseek_r1-claude:latest"
            Descripcion = "DeepSeek-R1 + Claude 3.5 Sonnet"
            Prioridad = 5
            Categoria = "hybrid"
        }
    )
    
    try {
        # ========== PASO 1: VERIFICAR OLLAMA ==========
        Write-LogMessage "    ‚îî‚îÄ Verificando estado de Ollama..." -Level INFO
        $ollamaRunning = $false
        try {
            $response = Invoke-WebRequest -Uri "http://localhost:11434/api/version" -TimeoutSec 5 -ErrorAction SilentlyContinue
            if ($response.StatusCode -eq 200) {
                $ollamaRunning = $true
                Write-LogMessage "    ‚îî‚îÄ ‚úÖ Ollama ejecut√°ndose correctamente" -Level SUCCESS
            }
        }
        catch {
            Write-LogMessage "    ‚îî‚îÄ ‚ö†Ô∏è Ollama no est√° ejecut√°ndose" -Level WARN
        }
        
        if (-not $ollamaRunning) {
            Write-LogMessage "    ‚îî‚îÄ üöÄ Iniciando servicio Ollama..." -Level INFO
            try {
                Start-Process -FilePath "ollama" -ArgumentList "serve" -WindowStyle Hidden -ErrorAction SilentlyContinue
                Start-Sleep -Seconds 5
                
                # Verificar nuevamente
                $response = Invoke-WebRequest -Uri "http://localhost:11434/api/version" -TimeoutSec 5 -ErrorAction SilentlyContinue
                if ($response.StatusCode -eq 200) {
                    Write-LogMessage "    ‚îî‚îÄ ‚úÖ Ollama iniciado exitosamente" -Level SUCCESS
                } else {
                    throw "Ollama no responde despu√©s de iniciarlo"
                }
            }
            catch {
                Write-LogMessage "‚ö†Ô∏è  No se pudo iniciar Ollama autom√°ticamente" -Level WARN
                Write-LogMessage "    ‚îî‚îÄ Ejecuta manualmente: ollama serve" -Level INFO
                return
            }
        }
        
        # ========== PASO 2: VERIFICAR MODELOS EXISTENTES ==========
        Write-LogMessage "    ‚îî‚îÄ üìã Verificando modelos instalados..." -Level INFO
        $modelosInstalados = @()
        try {
            $models = & ollama list 2>$null
            if ($models) {
                $modelosInstalados = $models | Where-Object { $_ -and $_.Trim() -ne "" }
                Write-LogMessage "    ‚îî‚îÄ Modelos encontrados: $($modelosInstalados.Count)" -Level INFO
            }
        }
        catch {
            Write-LogMessage "‚ö†Ô∏è  No se pudo listar modelos existentes" -Level WARN
        }
        
        # ========== PASO 3: ESTRATEGIA DE INSTALACI√ìN INTELIGENTE ==========
        $modelosPorInstalar = @()
        $hayModeloRecomendado = $false
        
        foreach ($modelo in $ModelosRecomendados) {
            $modeloNombre = $modelo.Nombre
            $yaInstalado = $modelosInstalados | Where-Object { $_ -match [regex]::Escape($modeloNombre.Split(':')[0]) }
            
            if ($yaInstalado) {
                Write-LogMessage "    ‚îî‚îÄ ‚úÖ $($modelo.Descripcion) ya est√° instalado" -Level SUCCESS
                $hayModeloRecomendado = $true
            } else {
                $modelosPorInstalar += $modelo
            }
        }
        
        # Si ya hay al menos un modelo recomendado, solo instalar uno adicional de m√°xima prioridad
        if ($hayModeloRecomendado) {
            Write-LogMessage "‚úÖ SISTEMA YA OPERATIVO - Al menos un modelo enterprise disponible" -Level SUCCESS
            
            # Instalar solo el modelo de mayor prioridad que falte
            $proximoModelo = $modelosPorInstalar | Sort-Object Prioridad | Select-Object -First 1
            if ($proximoModelo) {
                Write-LogMessage "üéØ Instalando modelo adicional de alta prioridad..." -Level INFO
                Install-Single-Model -ModelConfig $proximoModelo
            }
        } else {
            # No hay modelos, instalar al menos los 2 m√°s importantes
            Write-LogMessage "üöÄ CONFIGURACI√ìN INICIAL - Instalando modelos esenciales..." -Level INFO
            
            $modelosEsenciales = $modelosPorInstalar | Sort-Object Prioridad | Select-Object -First 2
            foreach ($modelo in $modelosEsenciales) {
                Install-Single-Model -ModelConfig $modelo
            }
        }
        
        Write-LogMessage "‚úÖ CONFIGURACI√ìN DE MODELOS COMPLETADA" -Level SUCCESS
        Write-LogMessage "    ‚îî‚îÄ El chatbot est√° listo para operar con IA avanzada" -Level SUCCESS
        
    }
    catch {
        Write-LogMessage "‚ö†Ô∏è  Error en configuraci√≥n de modelos: $($_.Exception.Message)" -Level WARN
        Write-LogMessage "    ‚îî‚îÄ Intentando instalaci√≥n de respaldo (phi3:mini)..." -Level WARN
        
        # Respaldo: instalar phi3:mini como m√≠nimo
        try {
            $pullProcess = Start-Process -FilePath "ollama" -ArgumentList "pull", "phi3:mini" -Wait -PassThru -NoNewWindow
            if ($pullProcess.ExitCode -eq 0) {
                Write-LogMessage "‚úÖ Modelo de respaldo (Phi-3-Mini) instalado" -Level SUCCESS
            }
        }
        catch {
            Write-LogMessage "‚ùå Error cr√≠tico: No se pudo instalar ning√∫n modelo" -Level ERROR
            Write-LogMessage "    ‚îî‚îÄ Instala manualmente: ollama pull phi3:mini" -Level ERROR
        }
    }
}

function Install-Single-Model {
    param([hashtable]$ModelConfig)
    
    $nombre = $ModelConfig.Nombre
    $descripcion = $ModelConfig.Descripcion
    
    Write-LogMessage "üì• Descargando $descripcion..." -Level INFO
    Write-LogMessage "    ‚îî‚îÄ Modelo: $nombre" -Level INFO
    Write-LogMessage "    ‚îî‚îÄ Este proceso puede tardar varios minutos..." -Level INFO
    
    try {
        $pullProcess = Start-Process -FilePath "ollama" -ArgumentList "pull", $nombre -Wait -PassThru -NoNewWindow
        
        if ($pullProcess.ExitCode -eq 0) {
            Write-LogMessage "‚úÖ $descripcion descargado exitosamente" -Level SUCCESS
            Write-LogMessage "    ‚îî‚îÄ Modelo disponible para el chatbot" -Level SUCCESS
        } else {
            Write-LogMessage "‚ö†Ô∏è  Descarga de $descripcion fall√≥" -Level WARN
            Write-LogMessage "    ‚îî‚îÄ Comando manual: ollama pull $nombre" -Level INFO
        }
    }
    catch {
        Write-LogMessage "‚ö†Ô∏è  Error descargando $descripcion`: $($_.Exception.Message)" -Level WARN
        Write-LogMessage "    ‚îî‚îÄ Comando manual: ollama pull $nombre" -Level INFO
    }
}

function Update-SourceCode {
    if ($SkipGitPull) {
        Write-LogMessage "‚è≠Ô∏è  Omitiendo actualizaci√≥n Git (par√°metro -SkipGitPull)" -Level WARN
        return
    }
    
    Write-LogMessage "üîÑ Verificando actualizaciones del repositorio Git..." -Level INFO
    
    # Verificar si Git est√° disponible
    try {
        $gitVersion = & git --version 2>$null
        if ($LASTEXITCODE -ne 0) {
            Write-LogMessage "‚ö†Ô∏è  Git no disponible - usando c√≥digo local" -Level WARN
            return
        }
    }
    catch {
        Write-LogMessage "‚ö†Ô∏è  Git no disponible - usando c√≥digo local" -Level WARN
        return
    }
    
    try {
        # Primero hacer fetch para ver si hay actualizaciones remotas
        Write-LogMessage "    ‚îî‚îÄ Verificando actualizaciones remotas..." -Level INFO
        & git fetch origin master 2>$null
        
        # Verificar si hay actualizaciones remotas disponibles
        $localCommit = & git rev-parse HEAD 2>$null
        $remoteCommit = & git rev-parse origin/master 2>$null
        
        if ($localCommit -eq $remoteCommit) {
            Write-LogMessage "‚úÖ Repositorio ya est√° actualizado - preservando cambios locales" -Level SUCCESS
            return
        }
        
        # Verificar si hay cambios locales
        $gitStatus = & git status --porcelain 2>$null
        $hasLocalChanges = $gitStatus -ne $null -and $gitStatus.Length -gt 0
        
        if ($hasLocalChanges) {
            Write-LogMessage "üìã Hay cambios locales Y actualizaciones remotas disponibles" -Level INFO
            Write-LogMessage "    ‚îî‚îÄ Cambios locales detectados:" -Level INFO
            $gitStatus | ForEach-Object { Write-LogMessage "      ‚Ä¢ $_" -Level INFO }
            
            # Estrategia inteligente: intentar rebase autom√°tico
            Write-LogMessage "    ‚îî‚îÄ Intentando fusi√≥n inteligente con rebase..." -Level INFO
            & git stash push -m "Auto-stash para rebase $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')" 2>$null
            
            $pullResult = & git pull --rebase origin master 2>&1
            
            if ($LASTEXITCODE -eq 0) {
                Write-LogMessage "‚úÖ C√≥digo actualizado exitosamente con rebase" -Level SUCCESS
                
                # Intentar restaurar cambios locales
                $stashList = & git stash list 2>$null
                if ($stashList -match "Auto-stash para rebase") {
                    Write-LogMessage "    ‚îî‚îÄ Restaurando cambios locales..." -Level INFO
                    $popResult = & git stash pop 2>&1
                    if ($LASTEXITCODE -eq 0) {
                        Write-LogMessage "‚úÖ Cambios locales restaurados exitosamente" -Level SUCCESS
                    } else {
                        Write-LogMessage "‚ö†Ô∏è  Conflictos detectados al restaurar cambios:" -Level WARN
                        Write-LogMessage "      $($popResult -join "`n")" -Level WARN
                        Write-LogMessage "    ‚îî‚îÄ Puedes resolver conflictos manualmente despu√©s" -Level INFO
                    }
                }
            } else {
                Write-LogMessage "‚ùå Error en rebase autom√°tico:" -Level ERROR
                Write-LogMessage "    $($pullResult -join "`n")" -Level ERROR
                
                # Restaurar stash en caso de error
                & git stash pop 2>$null
                Write-LogMessage "‚ö†Ô∏è  Cambios locales restaurados - actualizaci√≥n omitida" -Level WARN
            }
        } else {
            # No hay cambios locales, pull directo
            Write-LogMessage "    ‚îî‚îÄ Sin cambios locales - actualizando directamente..." -Level INFO
            $pullResult = & git pull origin master 2>&1
            
            if ($LASTEXITCODE -eq 0) {
                Write-LogMessage "‚úÖ C√≥digo fuente actualizado desde Git" -Level SUCCESS
            } else {
                Write-LogMessage "‚ö†Ô∏è  Warning: No se pudo actualizar - $($pullResult -join "`n")" -Level WARN
            }
        }
    }
    catch {
        Write-LogMessage "‚ö†Ô∏è  Error en operaci√≥n Git: $($_.Exception.Message)" -Level WARN
        Write-LogMessage "    ‚îî‚îÄ Continuando con c√≥digo local..." -Level INFO
    }
}

function Clear-BuildArtifacts {
    Write-LogMessage "üßπ Limpieza AGRESIVA de compilaci√≥n y cach√©..." -Level INFO
    
    # STEP 1: Terminar TODOS los procesos relacionados
    Write-LogMessage "    ‚îî‚îÄ Terminando procesos .NET y aplicaci√≥n..." -Level INFO
    Get-Process | Where-Object {
        $_.ProcessName -like "*ChatbotGomarco*" -or 
        $_.ProcessName -like "*dotnet*" -or
        $_.ProcessName -like "*MSBuild*"
    } | Stop-Process -Force -ErrorAction SilentlyContinue
    Start-Sleep -Seconds 2
    
    # STEP 2: Limpiar directorios de build
    $artifactDirs = @("bin", "obj")
    foreach ($dir in $artifactDirs) {
        if (Test-Path $dir) {
            Write-LogMessage "    ‚îî‚îÄ FORZANDO eliminaci√≥n: $dir" -Level INFO
            Remove-Item $dir -Recurse -Force -ErrorAction SilentlyContinue
            Start-Sleep -Seconds 1
        }
    }
    
    # STEP 3: Limpiar cach√© de .NET y NuGet AGRESIVAMENTE
    $cacheDirs = @(
        "$env:USERPROFILE\.nuget\packages\.tools",
        "$env:LOCALAPPDATA\NuGet\Cache", 
        "$env:LOCALAPPDATA\Microsoft\VisualStudio\*\ComponentModelCache",
        "$env:TEMP\NuGetScratch",
        "$env:USERPROFILE\.dotnet\toolResolverCache",
        "$env:LOCALAPPDATA\Microsoft\dotnet\cache",
        "$env:TEMP\dotnet-*"
    )
    
    foreach ($cachePattern in $cacheDirs) {
        $matchingDirs = Get-ChildItem $cachePattern -ErrorAction SilentlyContinue
        foreach ($dir in $matchingDirs) {
            if (Test-Path $dir) {
                Write-LogMessage "    ‚îî‚îÄ Limpiando cach√©: $($dir.Name)" -Level INFO
                Remove-Item $dir -Recurse -Force -ErrorAction SilentlyContinue
            }
        }
    }
    
    # STEP 4: Limpiar cach√© espec√≠fico de la aplicaci√≥n
    $appDataPath = "$env:APPDATA\ChatbotGomarco"
    if (Test-Path $appDataPath) {
        Write-LogMessage "    ‚îî‚îÄ Limpiando configuraciones y cach√© de app..." -Level INFO
        Remove-Item "$appDataPath\*.tmp" -Force -ErrorAction SilentlyContinue
        Remove-Item "$appDataPath\cache" -Recurse -Force -ErrorAction SilentlyContinue
        Remove-Item "$appDataPath\*.cache" -Force -ErrorAction SilentlyContinue
    }
    
    # STEP 5: Limpiar archivos temporales del sistema
    @("$env:TEMP\ChatbotGomarco*", "$env:TEMP\*.tmp") | ForEach-Object {
        if (Test-Path $_) {
            Remove-Item $_ -Recurse -Force -ErrorAction SilentlyContinue
        }
    }
    
    Write-LogMessage "‚úÖ Limpieza AGRESIVA completada - Forzando recompilaci√≥n total" -Level SUCCESS
}

function Restore-Dependencies {
    Write-LogMessage "üì¶ Restaurando dependencias NuGet..." -Level INFO
    
    try {
        $restoreOutput = & dotnet restore $Config.SolutionFile 2>&1
        
        if ($LASTEXITCODE -eq 0) {
            Write-LogMessage "‚úÖ Dependencias restauradas exitosamente" -Level SUCCESS
        } else {
            # Convertir restoreOutput a string para evitar errores de transformaci√≥n de par√°metros
            $restoreErrorString = if ($restoreOutput) { ($restoreOutput -join "`n") } else { "Sin detalles de error disponibles" }
            Write-LogMessage "‚ùå Error en restauraci√≥n: $restoreErrorString" -Level ERROR
            throw "Fall√≥ la restauraci√≥n de dependencias"
        }
    }
    catch {
        Write-LogMessage "‚ùå Error cr√≠tico en restauraci√≥n de dependencias" -Level ERROR
        throw
    }
}

function Build-Application {
    Write-LogMessage "üî® RECOMPILACI√ìN FORZADA en modo $($Config.BuildConfig)..." -Level INFO
    Write-LogMessage "    ‚îî‚îÄ INCLUYE: Correcciones de validaci√≥n de API Key implementadas" -Level INFO
    
    try {
        # PASO 1: Clean build forzado
        Write-LogMessage "    ‚îî‚îÄ Ejecutando dotnet clean..." -Level INFO
        $cleanOutput = & dotnet clean $Config.SolutionFile -c $Config.BuildConfig 2>&1
        
        # PASO 2: Build con flags de forzado
        $buildArgs = @(
            "build"
            $Config.SolutionFile
            "-c", $Config.BuildConfig
            "--no-restore"
            "--force"              # CR√çTICO: Fuerza recompilaci√≥n completa
            "--no-incremental"     # CR√çTICO: Evita build incremental
            "--verbosity", "normal"  # M√°s detalle para debug
        )
        
        Write-LogMessage "    ‚îî‚îÄ Ejecutando build completo SIN cach√©..." -Level INFO
        Write-LogMessage "    ‚îî‚îÄ IMPORTANTE: Capturando cambios de validaci√≥n de API mejorada" -Level SUCCESS
        $buildOutput = & dotnet @buildArgs 2>&1
        
        if ($LASTEXITCODE -eq 0) {
            Write-LogMessage "‚úÖ RECOMPILACI√ìN FORZADA exitosa" -Level SUCCESS
            Write-LogMessage "‚úÖ CAMBIOS DE API KEY incluidos en el build" -Level SUCCESS
            
            # Verificar que el executable se gener√≥ correctamente
            $exePath = "bin\$($Config.BuildConfig)\net8.0-windows\$($Config.ProjectName).exe"
            if (Test-Path $exePath) {
                $fileInfo = Get-Item $exePath
                Write-LogMessage "    ‚îî‚îÄ Ejecutable actualizado: $($fileInfo.LastWriteTime)" -Level SUCCESS
            }
        } else {
            Write-LogMessage "‚ùå Error en RECOMPILACI√ìN FORZADA:" -Level ERROR
            # Convertir buildOutput a string para evitar errores de transformaci√≥n de par√°metros
            $buildErrorString = if ($buildOutput) { ($buildOutput -join "`n") } else { "Sin detalles de error disponibles" }
            Write-LogMessage $buildErrorString -Level ERROR
            throw "Fall√≥ la recompilaci√≥n forzada"
        }
    }
    catch {
        Write-LogMessage "‚ùå Error cr√≠tico en recompilaci√≥n forzada" -Level ERROR
        throw
    }
}

function Stop-ExistingProcesses {
    Write-LogMessage "‚èπÔ∏è  Verificando procesos existentes..." -Level INFO
    
    $processes = Get-Process -Name $Config.ProjectName -ErrorAction SilentlyContinue
    
    if ($processes) {
        Write-LogMessage "    ‚îî‚îÄ Deteniendo $($processes.Count) proceso(s) existente(s)..." -Level INFO
        $processes | Stop-Process -Force -ErrorAction SilentlyContinue
        Start-Sleep -Seconds 2
        Write-LogMessage "‚úÖ Procesos anteriores detenidos" -Level SUCCESS
    } else {
        Write-LogMessage "‚úÖ No hay procesos previos ejecut√°ndose" -Level SUCCESS
    }
}

function Start-Application {
    Write-LogMessage "üöÄ Iniciando aplicaci√≥n actualizada..." -Level INFO
    Write-LogMessage "    ‚îî‚îÄ Con correcciones de validaci√≥n de API Key implementadas" -Level SUCCESS
    
    try {
        # M√©todo 1: Ejecutar desde proyecto
        Write-LogMessage "    ‚îî‚îÄ M√©todo 1: Ejecutando desde proyecto..." -Level INFO
        
        $runArgs = @(
            "run"
            "--project", $Config.ProjectFile
            "--no-build"
        )
        
        Start-Process -FilePath "dotnet" -ArgumentList $runArgs -WindowStyle Hidden
        
        # Verificar que se inici√≥ correctamente
        Start-Sleep -Seconds 3
        
        $runningProcess = Get-Process -Name "dotnet" -ErrorAction SilentlyContinue | 
                         Where-Object { $_.ProcessName -eq "dotnet" }
        
        if ($runningProcess) {
            Write-LogMessage "‚úÖ Aplicaci√≥n iniciada correctamente (PID: $($runningProcess.Id))" -Level SUCCESS
            Write-LogMessage "‚úÖ VALIDACI√ìN DE API KEY mejorada est√° ACTIVA" -Level SUCCESS
            return $true
        } else {
            # M√©todo 2: Ejecutar binario directo
            Write-LogMessage "    ‚îî‚îÄ M√©todo 2: Ejecutando binario directo..." -Level INFO
            
            $exePath = "bin\$($Config.BuildConfig)\net8.0-windows\$($Config.ProjectName).exe"
            
            if (Test-Path $exePath) {
                Start-Process -FilePath $exePath
                Write-LogMessage "‚úÖ Aplicaci√≥n iniciada desde binario" -Level SUCCESS
                Write-LogMessage "‚úÖ VALIDACI√ìN DE API KEY mejorada est√° ACTIVA" -Level SUCCESS
                return $true
            } else {
                Write-LogMessage "‚ùå No se pudo encontrar el ejecutable" -Level ERROR
                return $false
            }
        }
    }
    catch {
        Write-LogMessage "‚ùå Error al iniciar aplicaci√≥n: $($_.Exception.Message)" -Level ERROR
        return $false
    }
}

function Show-Summary {
    param([bool]$Success)
    
    Write-Host "`n" -NoNewline
    Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Green
    
    if ($Success) {
        Write-Host "‚ïë                     üéâ ACTUALIZACI√ìN COMPLETA üéâ                ‚ïë" -ForegroundColor Green
        Write-Host "‚ïë                 ‚úÖ CAMBIOS DE API KEY INCLUIDOS ‚úÖ               ‚ïë" -ForegroundColor Green
    } else {
        Write-Host "‚ïë                     ‚ùå ACTUALIZACI√ìN FALLIDA ‚ùå                 ‚ïë" -ForegroundColor Red
    }
    
    Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Green
    
    Write-Host "`nüìä Resumen de la operaci√≥n:" -ForegroundColor Cyan
    Write-Host "    ‚Ä¢ Proyecto: $($Config.ProjectName)" -ForegroundColor White
    Write-Host "    ‚Ä¢ Configuraci√≥n: $($Config.BuildConfig)" -ForegroundColor White
    Write-Host "    ‚Ä¢ Timestamp: $(Get-Date)" -ForegroundColor White
    Write-Host "    ‚Ä¢ Log: $script:LogFile" -ForegroundColor White
    
    if ($Success) {
        Write-Host "`nüí° La aplicaci√≥n deber√≠a estar ejecut√°ndose ahora." -ForegroundColor Green
        Write-Host "üîß MEJORAS INCLUIDAS:" -ForegroundColor Yellow
        Write-Host "   ‚úÖ Validaci√≥n de API Key mejorada" -ForegroundColor Green
        Write-Host "   ‚úÖ Debug autom√°tico de caracteres invisibles" -ForegroundColor Green
        Write-Host "   ‚úÖ Limpieza autom√°tica de espacios problem√°ticos" -ForegroundColor Green
        Write-Host "   ‚úÖ Mensajes de error m√°s informativos" -ForegroundColor Green
        Write-Host "" -ForegroundColor Green
        Write-Host "üß† MODELOS AI ENTERPRISE DISPONIBLES:" -ForegroundColor Cyan
        Write-Host "   üöÄ DeepSeek-R1 7B (Razonamiento Avanzado)" -ForegroundColor Green
        Write-Host "   ü¶ô Llama 3.1 + Claude 3.5 Sonnet (Conversacional)" -ForegroundColor Green
        Write-Host "   üß† DeepSeek-R1 + Claude (Razonamiento + Conversaci√≥n)" -ForegroundColor Green
        Write-Host "   ‚ö° DeepSeek-V3 (General Purpose)" -ForegroundColor Green
        Write-Host "   üîß Phi-3-Mini (Microsoft - Estable)" -ForegroundColor Green
    } else {
        Write-Host "`nüìã Revisa el archivo de log para detalles del error." -ForegroundColor Yellow
    }
}

# ====================================================================
# FUNCI√ìN PRINCIPAL
# ====================================================================
function Main {
    try {
        # Inicializar logging
        if (-not (Test-Path $Config.LogDirectory)) {
            New-Item -ItemType Directory -Path $Config.LogDirectory -Force | Out-Null
        }
        
        $script:LogFile = Join-Path $Config.LogDirectory "deployment_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
        
        # Limpiar logs antiguos
        Get-ChildItem $Config.LogDirectory -Filter "deployment_*.log" | 
            Sort-Object LastWriteTime -Descending | 
            Select-Object -Skip $Config.MaxLogFiles | 
            Remove-Item -Force -ErrorAction SilentlyContinue
        
        # Header empresarial
        Write-Host "`n"
        Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Green
        Write-Host "‚ïë              ü§ñ CHATBOT GOMARCO - AUTO UPDATER ü§ñ              ‚ïë" -ForegroundColor Green
        Write-Host "‚ïë                PowerShell Enterprise DevOps Solution             ‚ïë" -ForegroundColor Green
        Write-Host "‚ïë            üß† DEEPSEEK + CLAUDE + PHI MODELS INCLUDED üß†        ‚ïë" -ForegroundColor Cyan
        Write-Host "‚ïë                      üîß API KEY FIXES INCLUDED üîß                ‚ïë" -ForegroundColor Yellow
        Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Green
        
        Write-LogMessage "=== INICIANDO PROCESO DE ACTUALIZACI√ìN AUTOM√ÅTICA ===" -Level INFO
        Write-LogMessage "üéØ INCLUYENDO: Correcciones de validaci√≥n de API Key" -Level SUCCESS
        Write-LogMessage "üß† INCLUYENDO: Modelos DeepSeek, Claude-style y Phi" -Level SUCCESS
        
        # Pipeline de actualizaci√≥n
        Test-Prerequisites
        Update-SourceCode
        
        # Forzar limpieza para asegurar que el frontend se actualice correctamente
        Write-LogMessage "üîÑ Forzando limpieza completa para actualizaci√≥n del frontend..." -Level INFO
        Clear-BuildArtifacts
        
        Restore-Dependencies
        Stop-ExistingProcesses
        Build-Application
        $appStarted = Start-Application
        
        Show-Summary -Success $appStarted
        
        Write-LogMessage "=== PROCESO COMPLETADO EXITOSAMENTE ===" -Level SUCCESS
        Write-LogMessage "üéâ CAMBIOS DE API KEY ACTIVOS EN LA APLICACI√ìN" -Level SUCCESS
        
    }
    catch {
        Write-LogMessage "=== ERROR CR√çTICO: $($_.Exception.Message) ===" -Level ERROR
        Show-Summary -Success $false
        throw
    }
}

# ====================================================================
# EJECUCI√ìN
# ====================================================================
if ($MyInvocation.InvocationName -ne '.') {
    Main
} 